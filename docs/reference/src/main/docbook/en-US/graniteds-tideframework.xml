<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" []>
   
<chapter id="graniteds.tideframework">
	<title>Tide client framework</title>
	<para>
	GraniteDS comes with a built-in client framework named Tide that is based on the concept of contextual components and serves as the basis for many advanced
	features (such as data management or simplified remoting).
	</para>
	
	<para>
	This client framework implements some classic features of usual Java frameworks such as Spring or Seam and provides a programming model that should look 
	familiar to Java developers. However it tries to be as transparent and unobtrusive as possible and yet stay close from the Flex framework concepts and 
	traditional usage.	  
	</para>
	<para>
	The framework features notably:
	<itemizedlist>
       <listitem>
       Dependency Injection: using a programmatic way of declaring client components, Tide makes possible to write applications with a decoupled and testable
       architecture. The use of annotations to control injection and of various conventions greatly reduces the amount of code needed to wire the different
       parts of the application. See <link linkend="tide.di">here</link> for details.
       </listitem>
       <listitem>
       Event Bus: the Flex event model is very powerful and makes possible to decouple various parts of the application. However it requires a lot of manual setup
       to wire the event listeners to the dispatchers. Tide brings an event bus that centralizes the propagation of events and removes the need for wiring events
       manually. See <link linkend="tide.eventbus">here</link>.
       </listitem>
       <listitem>
       Contextual Components and Conversations: it is relatively usual in enterprise applications to have separate portions of the application that should be 
       isolated in different tabs or windows. For example in an insurance application it could be necessary to be able to open simultaneously many tabs for 
       different customer records. Tide brings the concept of client conversation that makes possible to completely isolate different parts of the application 
       while reusing the same components and events. See <link linkend="tide.core">here</link>.
       </listitem>
	</itemizedlist>
	</para>
	
	<section id="tide.gettingstarted">
	   <title>Getting Started</title>
	   <para>
	   To get started quickly and see what Tide can do, let's see how we can Tidify a simple Hello World example in a few steps. 
	   In a first iteration, we do everything in one simple MXML:
	   </para>
	   <programlisting role="XML">
<![CDATA[<?xml version="1.0" encoding="utf-8"?>
<mx:Application
    xmlns:mx="http://www.adobe.com/2006/mxml"
    xmlns="*"
    preinitialize="Tide.getInstance().initApplication()">

    <mx:Script>
        import org.granite.tide.Tide;
        import org.granite.tide.Component;
        import org.granite.tide.events.TideResultEvent;
        
        [In]
        public var helloService:Component;
        
        private function hello():void {
            helloService.hello(iname.text, helloResult);
        }
        
        private function helloResult(event:TideResultEvent):void {
            lmessage.text = event.result as String;
        }
    </mx:Script>
    
    <mx:TextInput id="iname"/>
    <mx:Button label="Hello" click="hello()"/>
    <mx:Label id="lmessage"/>
</mx:Application>
]]>
	   </programlisting>
	   <para>
	   This is almost exactly the same example that we have seen in the <link linkend="remoting.tideremoting">Tide Remoting</link> chapter. In this first step
	   we see only the injection feature of Tide with the annotation <literal>[In]</literal> that can be placed on any writeable property of the component 
	   (public or with a setter).
	   </para>
	   <para>
	   Tide will by default consider any injection point with a type <literal>Component</literal> (or any type extending <literal>Component</literal>)
	   as a remoting injection and will create and inject a client proxy for a service named <literal>helloService</literal> (by default the name of the property
	   is used as the name of the injected component). 
	   </para>
	   <para>
	   This is more than enough for a Hello World application, but if we continue the application this way, everything will be in the same MXML. So in a first 
	   iteration we want at least to separate the application initialization part and the real UI part. We can for example create a new MXML file named 
	   <literal>Hello.mxml</literal>:
	   </para>
       <programlisting role="XML">
<![CDATA[<?xml version="1.0" encoding="utf-8"?>
<mx:Application
    xmlns:mx="http://www.adobe.com/2006/mxml"
    xmlns="*"
    preinitialize="Tide.getInstance().initApplication()">

    <mx:Script>
        import org.granite.tide.Tide;
    </mx:Script>
    
    <Hello id="hello"/>
</mx:Application>]]>
       </programlisting>
       <para>
       <literal>Hello.mxml:</literal>
       </para>
       <programlisting role="XML">
<![CDATA[<?xml version="1.0" encoding="utf-8"?>
<mx:Panel
    xmlns:mx="http://www.adobe.com/2006/mxml"
    xmlns="*">
    
    <mx:Metadata>[Name]</mx:Metadata>

    <mx:Script>
        import org.granite.tide.Component;
        import org.granite.tide.events.TideResultEvent;
        
        [In]
        public var helloService:Component;
        
        private function hello():void {
            helloService.hello(iname.text, helloResult);
        }
        
        private function helloResult(event:TideResultEvent):void {
            lmessage.text = event.result as String;
        }
    </mx:Script>
    
    <mx:TextInput id="iname"/>
    <mx:Button label="Hello" click="hello()"/>
    <mx:Label id="lmessage"/>
</mx:Panel>]]>
       </programlisting>
       <para>
       This is a bit better, the main UI is now defined in its own MXML. Tide has not much to do here, but note that we have added the <literal>[Name]</literal>
       metadata annotation on the MXML to instruct Tide that it has to manage the component and inject the dependencies on properties marked with 
       <literal>[In]</literal>. This was not necessary in the initial case because the main application itself is always registered as a component managed by Tide
       (under the name <literal>application</literal>).
       </para>
       <para>
       The next step is to decouple our UI component from the server interaction, so we can for example reuse the same UI component in another context or 
       simplify the testing of the server interaction with a mock controller.
       </para>
       <para>
       The first thing we can do is introduce a controller component (the C in MVC) that will handle this interaction and an interface so that we can easily 
       switch the controller implementation. Then we can just bind it to the MXML component: 
       </para>
       
       <programlisting role="AS3">     
package com.myapp.controller {

    [Bindable]
    public interface IHelloController {
    
        function hello(name:String):void;
        
        function get message():String;
    }
}
        </programlisting>
	   <programlisting role="AS3">
package com.myapp.controller {

    import org.granite.tide.Component;
    import org.granite.tide.events.TideResultEvent;

	[Name("helloController")]
	public class HelloController implements IHelloController {
	    
	    [In]
	    public var helloService:Component;
	    
	    [Bindable]
	    public var message:String;
	    
	    public function hello(name:String):void {
	        helloService.hello(name, helloResult);
	    }
	    
	    private function helloResult(event:TideResultEvent):void {
	        message = event.result as String;
	    }
	}
}
	   </programlisting>
	   <para>
	   We have to configure the controller in the main MXML and use it in the view:
	   </para>
       <programlisting role="XML">
<![CDATA[<?xml version="1.0" encoding="utf-8"?>
<mx:Application
    xmlns:mx="http://www.adobe.com/2006/mxml"
    xmlns="*"
    preinitialize="Tide.getInstance().initApplication()">

    <mx:Script>
        import org.granite.tide.Tide;
        
        Tide.getInstance().addComponents([HelloController]);
    </mx:Script>
    
    <Hello id="hello"/>
</mx:Application>]]>
       </programlisting>
       <programlisting role="XML">
<![CDATA[<?xml version="1.0" encoding="utf-8"?>
<mx:Panel
    xmlns:mx="http://www.adobe.com/2006/mxml"
    xmlns="*">
    
    <mx:Metadata>[Name]</mx:Metadata>

    <mx:Script>
        import com.myapp.controller.IHelloController;
        
        [Bindable] [Inject]
        public var helloController:IHelloController;
    </mx:Script>
    
    <mx:TextInput id="iname"/>
    <mx:Button label="Hello" click="helloController.hello(iname.text)"/>
    <mx:Label id="lmessage" text="{helloController.message}"/>
</mx:Panel>]]>
       </programlisting>
       <para>
       This is already quite clean, and completely typesafe. The annotation <literal>[Inject]</literal> indicates that Tide should inject any managed
       component which class extends or implements the specified type, contrary to the annotation <literal>[In]</literal> that is used to inject a 
       component by name. Here the instance of <literal>HelloController</literal> will be injected, in a test case you could easily configure an 
       alternative <literal>TestHelloController</literal> implementing the same interface.
       </para>
       <para>
       This kind of architecture is inspired by JSF (Java Server Faces) and works fine. However there is still a bit of coupling between the views and the controllers, 
       and it does not really follow the usual event-based style of the Flex framework. To obtain a more pure MVC model, we have to add a model
       component that will hold the state of the application, and an event class dispatched through the Tide event bus to decouple the view and the controller: 
       </para>
       <programlisting role="AS3">
package com.myapp.events {

    import org.granite.tide.events.AbstractTideEvent;
    
    public class HelloEvent extends AbstractTideEvent {
    
        public var name:String;
        
        public function HelloEvent(name:String):void {
            super();
            this.name = name;
        }
    }
}
       </programlisting>
       <programlisting role="AS3">     
package com.myapp.model {

    [Bindable]
    public interface IHelloModel {
    
        function get message():String;
        
        function set message(message:String):void;
    }
}
        </programlisting>
       <programlisting role="AS3">
package com.myapp.model {

    [Name("helloModel")]
    public class HelloModel implements IHelloModel {
        
        [Bindable]
        public var message:String;
    }
}
       </programlisting>
       <para>
       The controller will now observe our custom event, and set the value of the message property in the model:
       </para>
       <programlisting role="AS3">
package com.myapp.controller {

    import org.granite.tide.Component;
    import org.granite.tide.events.TideResultEvent;
    import com.myapp.events.HelloEvent;

    [Name("helloController")]
    public class HelloController implements IHelloController {
        
        [In]
        public var helloService:Component;
        
        [Inject]
        public var helloModel:IHelloModel;
        
        [Observer]
        public function hello(event:HelloEvent):void {
            helloService.hello(event.name, helloResult);
        }
        
        private function helloResult(event:TideResultEvent):void {
            helloModel.message = event.result as String;
        }
    }
}
       </programlisting>
       <para>
       Lastly we configure the new model component and dispatch the custom event from the UI: 
       </para>
       <programlisting role="XML">
<![CDATA[<?xml version="1.0" encoding="utf-8"?>
<mx:Application
    xmlns:mx="http://www.adobe.com/2006/mxml"
    xmlns="*"
    preinitialize="Tide.getInstance().initApplication()">

    <mx:Script>
        import org.granite.tide.Tide;
        
        Tide.getInstance().addComponents([HelloController, HelloModel]);
    </mx:Script>
    
    <Hello id="hello"/>
</mx:Application>]]>
       </programlisting>
       <programlisting role="XML">
<![CDATA[<?xml version="1.0" encoding="utf-8"?>
<mx:Panel
    xmlns:mx="http://www.adobe.com/2006/mxml"
    xmlns="*">
    
    <mx:Metadata>[Name]</mx:Metadata>

    <mx:Script>
        import com.myapp.events.HelloEvent;
        import com.myapp.model.IHelloModel;
        
        [Bindable] [Inject]
        public var helloModel:IHelloModel;
    </mx:Script>
    
    <mx:TextInput id="iname"/>
    <mx:Button label="Hello" click="dispatchEvent(new HelloEvent(iname.text))"/>
    <mx:Label id="lmessage" text="{helloModel.message}"/>
</mx:Panel>]]>
       </programlisting>
       <para>
       The main difference here is that we use an event to communicate between the view and the controller. This would allow for example many controllers
       to react to the same user action. The view does not know which component will handle the event, and the controllers simply specify that they are interested
       in the event <literal>HelloEvent</literal> with the annotation <literal>[Observer]</literal> on a public handler method. Tide automatically wires
       the dispatcher and the observers through its event bus by matching the event type. 
       </para>
       <para>
       Note that the <literal>HelloEvent</literal> class extends a (pseudo) abstract class of the Tide framework. If you don't want any such dependency, 
       you can use any Flex event but then you have to add an annotation <literal>[ManagedEvent]</literal> on the dispatcher to instruct Tide which events it 
       has to manage. See more below in the section <link linkend="tide.eventbus">Event Bus</link>.
       </para>
       <para>
       Now we have a completely decoupled and testable architecture, however everything is wired typesafely, meaning that any error will be detected at 
       compile time and not at runtime. 
       </para>
       <para>
       With some Java server frameworks (Spring and CDI) we can even achieve complete client/server type safety by generating a typed client proxy. 
       The controller would then look like:
       </para>
       <programlisting role="AS3">
package com.myapp.controller {

    import org.granite.tide.Component;
    import org.granite.tide.events.TideResultEvent;
    import com.myapp.events.HelloEvent;
    import com.myapp.service.HelloService;

    [Name("helloController")]
    public class HelloController implements IHelloController {
        
        [Inject]
        public var helloService:HelloService;
        
        [Inject]
        public var helloModel:IHelloModel;
        
        [Observer]
        public function hello(event:HelloEvent):void {
            helloService.hello(event.name, helloResult);
        }
        
        private function helloResult(event:TideResultEvent):void {
            helloModel.message = event.result as String;
        }
    }
}
       </programlisting>
       <para>
       Hopefully you have now a relatively clear idea on what it's all about. The following sections will describe all this in more details.
       </para>
	</section>
	
	<section id="tide.init">
	   <title>Application Initialization</title>
	   <para>
	   The framework mainly consists in a global singleton object that holds the full configuration of the application. This singleton of type <literal>Tide</literal>
	   has to be initialized in the <literal>preinitialize</literal> handler of the main application:
	   </para>
	   <programlisting role="XML">
<![CDATA[<mx:Application ...
    preinitialize="Tide.getInstance().initApplication()">
    ...
</mx:Application>
]]>
	   </programlisting>
	   <note><para>
	   You will have to use the framework-specific Tide singletons (judiciously named <literal>Ejb</literal>,<literal>Spring</literal>, 
	   <literal>Seam</literal> and <literal>Cdi</literal>) to benefit from all the features of these specific framework integrations.
	   </para></note>
	   <para>
	   For example with Spring:
	   </para>
       <programlisting role="XML">
<![CDATA[<mx:Application ...
    preinitialize="Spring.getInstance().initApplication()">
    ...
</mx:Application>
]]>
       </programlisting>
       <para>
       The Tide framework makes heavy use of Flex annotations, so you will need to configure your build system (Flash Builder, Ant or Maven) correctly so the Flex 
       compiler keeps the necessary annotations at runtime (see the Project Setup chapter for <link linkend="setup.ant">Ant</link>, 
       <link linkend="setup.maven">Maven</link> and <link linkend="setup.flashbuilder">Flash Builder</link>).
       </para>
	</section>
    
    <section id="tide.core">
       <title>Contexts and Components</title>
       <para>
       The core concepts of the Tide framework are the <emphasis>context</emphasis> and the <emphasis>component</emphasis>.
       </para>
       <para>
       Components are stateful objects that can be of any ActionScript 3 class with a default constructor and can have a unique instance stored in each 
       context of the application. Usually components have a <emphasis>name</emphasis> so they can be referenced easily.
       </para>
       <para>
       There are two main kinds of contexts:
       <itemizedlist>
            <listitem>
            The global context is a unique context that exists during the whole lifetime of the Flex application. It can be compared to to the server-side session.
            </listitem>
            <listitem>
            The conversation contexts are temporary contexts that can be created and destroyed at any time during the lifetime of the application. Many 
            conversation contexts can exist simultaneously and are isolated from each other. A conversation context always has an identifier. A conversation
            context is usually tied to a particular use case in the application (a wizard-style form with many pages, or a window displaying some data).
            </listitem>
       </itemizedlist>
       </para>
       <para>
       A context is mostly a container for component instances. A component should be defined with a scope that describes in which context its instances will be 
       created and managed. There are three available scopes:
       <itemizedlist>
            <listitem>
            The session scope corresponds to the global context. A component in the session scope can have only one instance in the whole application.
            </listitem>
            <listitem>
            The conversation scope corresponds to the conversation context. A component in the conversation scope cannot exist in the global context and will have
            one unique instance in each conversation context.
            </listitem>
            <listitem>
            The event scope is not tied to a particular kind of contexts. A component in the event scope will have one unique instance in each context, global or
            conversation.
            </listitem>
       </itemizedlist>
       </para>
       
       <para>
       The global context object can easily be retrieved from the Tide singleton:
       </para>
       <programlisting role="AS3">
var tideContext:Context = Tide.getInstance().getContext();
       </programlisting>
       <para>
       Conversation contexts can be retrieved by their identifier and are automatically created if they do not exist:
       </para>
       <programlisting role="AS3">
var tideContext:Context = Tide.getInstance().getContext("someConversationId");
       </programlisting>
       <para>
       Note however that this is not the recommended way of working with conversation contexts. See the <link linkend="tide.conversations">Conversations</link> section.
       </para>
       
       <para>
       Components can be registered programmatically by any of the following methods:
        <itemizedlist>
            <listitem>
            Manual registration with <literal>Tide.getInstance().addComponent()</literal>:
            <programlisting role="AS3">
Tide.getInstance().addComponent("myComponent", MyComponent):
            </programlisting>
            This method takes two main arguments: the component name and the component class. 
            </listitem>
            <listitem>
            It also has optional arguments that can be used to describe the metadata of the component:
            <programlisting role="AS3">
Tide.getInstance().addComponent(componentName, componentClass, inConversation, autoCreate, restrict);
            </programlisting>
            <literal>inConversation</literal> is a <literal>boolean</literal> value indicating whether the component in conversation-scoped 
            (it is <literal>false</literal> by default), <literal>autoCreate</literal> is <literal>true</literal> by default and indicates that the component will
            be automatically instantiated by the container. Finally <literal>restrict</literal> is related to security and indicates that the component instance 
            has to be destroyed when the user logs out from the application (so that its state cannot be accessed by unauthenticated users). 
            </listitem>
            <listitem>
            When necessary, it is possible to define initial values for some properties of the component instances with:
            <programlisting role="AS3">
Tide.getInstance().addComponentWithFactory("myComponent", MyComponent, { property1: value1, property2: value2 });
            </programlisting>
            Of course, this assumes that the component class has accessible setters for the properties specified in the initialization map. Values may be 
            string expressions of the form <literal>#{component.property}</literal>, and are then evaluated at run time as a chain of properties starting 
            from the specified contextuel component. All other values are assigned as is. 
            </listitem>
        </itemizedlist>
        </para>
        <para> 
        It is alternatively possible (and indeed recommended) to describe the metadata of the component with annotations in the component class. 
        This simplifies the component registration and is often more readable.
        </para>
        <programlisting role="AS3">
Tide.getInstance().addComponents([MyComponent]);

[Name("myComponent")]
public class MyComponent {

    public MyComponent():void {
    }
}
       </programlisting> 
       <warning><para>
       A component class must have a default constructor.
       </para></warning>
       <para>
       Once a component is registered, you can get an instance of the component from the <literal>Context</literal> object by its name, for example 
       <literal>tideContext.myComponent</literal> will return the unique instance of the component <literal>MyComponent</literal> that we have defined before.       
       </para>
       <para>
       You can also retrieve the instance of a component that extend a particular type with <literal>tideContext.byType(MyComponent)</literal>. Of course
       it is more useful when specifying an interface so you can get its configured implementation: <literal>tideContext.byType(IMyComponent)</literal>.
       When many implementations of an interface are expected to exist in the context, you can use <literal>tideContext.allByType(IMyComponent)</literal>
       to retrieve all of them. 
       </para>
       <note><para>
       If no component has been registered with a particular name, <literal>tideContext.someName</literal> will by default return a client proxy for a remote 
       service named <literal>someName</literal>. In particular <literal>tideContext.someName</literal> will return <literal>null</literal> only if a component 
       named <literal>someName</literal> has been configured with the metadata <literal>autoCreate</literal> set to <literal>false</literal>. 
       </para></note>
       
       <para>
       When using dependency injection annotations (<literal>[In]</literal>, <literal>[Out]</literal> and <literal>[Inject]</literal>) on component properties, 
       Tide implicitly registers a component of the target type when it is a concrete class (not an interface):
       </para>
       <programlisting role="AS3">
[Name("myInjectedComponent")]
public class MyInjectedComponent {
	[In]
	public var myComponent:MyComponent;
}
       </programlisting>
       <para>
       Will implicity register a component of class <literal>MyComponent</literal>, even if you have never called <literal>Tide.addComponent()</literal> for 
       this type.
       </para>
       
       <para>
       Besides all these options for registering components, it is also possible to dynamically assign a component instance at any time in a Tide context with
       <literal>tideContext.myComponent = new MyComponent()</literal>. This allows you to precisely control the instantiation of the component and will 
       implicitly register the corresponding component from the object class. For example you can use this feature to switch at runtime between different 
       implementations of a component interface. 
       </para>
       
       <para>
       The last case is the one of UI components that are added and removed from the Flex stage. One of the things that Tide does at initialization time
       in the method <literal>initApplication()</literal> is registering listeners for the Flex events <literal>add</literal> and <literal>remove</literal>.
       On the <literal>add</literal> event, it automatically registers any component annotated with <literal>[Name]</literal> and puts its instance in the context. 
       It also removes the instance from the context when getting the <literal>remove</literal> event.
       </para> 
       <para>
       Note that this behaviour can incur a significant performance penalty due to the ridiculously slow implementation of reflection in ActionScript 
       so it can be disabled by <literal>Tide.getInstance().initApplication(false)</literal>. You will then have to wire the UI components manually. 
       </para>
    </section>
    
	<section id="tide.di">
	   <title>Dependency Injection</title>	   
	   <para>
	   Once you have configured all components of the application, the Tide framework is able to inject the correct component instances for you anywhere you 
	   specify that you have a dependency by using one of the annotations <literal>[In]</literal> or <literal>[Inject]</literal>.
	   </para>
	   <para>
	   The annotation <literal>[In]</literal> indicates a name-based injection point, meaning that Tide will assign the instance of the component with the 
	   specified name:
	   </para>
	   <programlisting role="AS3">
[Name("myInjectedComponent")]
public class MyInjectedComponent {

    [In("myComponent")]
    public var myComponent:IMyComponent;
    
}
	   </programlisting>
	   <warning><para>
	   Due to limitations in AS3 reflection, properties annotated with <literal>[In]</literal> must be public or have a public setter (or use a custom 
	   Flex namespace).
	   </para></warning>
	   <para>
	   It is important to note that the injection in Tide is not done statically at instantiation time. It is implemented as a Flex data binding between the 
	   source <literal>tideContext.myComponent</literal> and the target <literal>myInjectedComponent.myComponent</literal>. That means that any change in the
	   context instance is automatically propagated to all injected instances. For example if you assign manually a new instance to the context with
	   <literal>tideContext.myComponent = new MyExtendedComponent()</literal>, the property <literal>myInjectedComponent.myComponent</literal> will be 
	   updated accordingly (assuming <literal>MyExtendedComponent</literal> implements <literal>IMyComponent</literal>, otherwise you will get a runtime exception).	   
	   </para>
	   <para>
	   In most cases, you can omit the name argument from the annotation and let Tide use the property name as a default. The previous example can be reduced to:
	   </para>
       <programlisting role="AS3">
[In]
public var myComponent:IMyComponent;
       </programlisting>
       <para>
       You can also use property chain expressions of the form <literal>#{mySourceComponent.myProperty}</literal>:
       </para>
       <programlisting role="AS3">
[In("#{mySourceComponent.myProperty}")]
public var myComponent:IMyComponent;
       </programlisting>
       <para>
       Tide will then bind <literal>tideContext.mySourceComponent.myProperty</literal> to the target <literal>myInjectedComponent.myComponent</literal>. 
       </para>
       
       <para>
       Depending on the <literal>autoCreate</literal> metadata of the source component, Tide will automatically instantiate the component to bind it to 
       the injection point. For components that are not auto created, you can force the instantiation at the injection point with:
       </para>
       <programlisting role="AS3">
[In(create="true")]
public var myComponent:IMyComponent;
       </programlisting>
       <para>
       This ensures that <literal>myComponent</literal> will never be <literal>null</literal>.
       </para>
       
       <para>
       Tide also supports the concept of outjection, meaning that a component can publish some of its state to the context. This can be done with the annotation
       <literal>[Out]</literal>, and just works in a similar way as injection by creating a data binding between the outjecting component and the context:
       </para>
       <programlisting role="AS3">
[Name("myOutjectingComponent")]
public class MyOutjectingComponent {

    [Bindable] [Out]
    public var myComponent:IMyComponent;
    
    public function doSomething():void {
        myComponent = new MyComponent();
    }
}
       </programlisting>
       <para>
       In this case, Tide will create a binding from <literal>myOutjectingComponent.myComponent</literal> to <literal>tideContext.myComponent</literal>.
       It is important that outjected properties are <literal>[Bindable]</literal> because this is how data binding is able to propagate the value to listeners.
       The method <literal>doSomething</literal> will change the value of <literal>myComponent</literal> in the context and also propagate it to all
       components having it in one of their injection points.
       </para>
       
       <para>
       With server frameworks that support bijection (only Seam for now), you can also mark the outjection as remote, so Tide will also propagate the value 
       to the server context. This requires that the value is serialized to the server and is thus used generally with entities or simple values (strings or numbers): 
       </para>
       <programlisting role="AS3">
[Name("myOutjectingComponent")]
public class MyOutjectingComponent {

    [Bindable] [Out(remote="true")]
    public var myEntity:MyEntity;
    
    public function doSomething():void {
        myEntity = new MyEntity();
    }
}
       </programlisting>
       <para>
       Outjection is an interesting way of decoupling controllers and views. In our initial example, we could have used outjection instead of a typesafe model:
       </para>
       <programlisting role="XML">
<![CDATA[<?xml version="1.0" encoding="utf-8"?>
<mx:Panel
    xmlns:mx="http://www.adobe.com/2006/mxml"
    xmlns="*">
    
    <mx:Metadata>[Name]</mx:Metadata>

    <mx:Script>
        import com.myapp.events.HelloEvent;
        
        [Bindable] [In]
        public var message:String;
    </mx:Script>
    
    <mx:TextInput id="iname"/>
    <mx:Button label="Hello" click="dispatchEvent(new HelloEvent(iname.text))"/>
    <mx:Label id="lmessage" text="{message}"/>
</mx:Panel>]]>
       </programlisting>
       <programlisting role="AS3">
package com.myapp.controller {

    import org.granite.tide.events.TideResultEvent;
    import com.myapp.events.HelloEvent;
    import com.myapp.service.HelloService;

    [Name("helloController")]
    public class HelloController implements IHelloController {
        
        [Inject]
        public var helloService:HelloService;
        
        [Bindable] [Out]
        public var message:String;
        
        [Observer]
        public function hello(event:HelloEvent):void {
            helloService.hello(event.name, helloResult);
        }
        
        private function helloResult(event:TideResultEvent):void {
            this.message = event.result as String;
        }
    }
}
       </programlisting>
       <para>
       This is very convenient but note that it's relatively fragile and difficult to maintain as it is based on string names, and that you have to take care 
       of name conflicts in the global context. Here you would have to ensure that no other component use the name <literal>message</literal> for another purpose.
       This problem can however be limited by defining proper naming conventions (for example with a prefix per module, or per use case).
       </para>
       
       <para>
       Specifying an injection point with <literal>[In]</literal> is also based on string names and thus not typesafe. Alternatively you can (and should whenever
       possible) use the annotation <literal>[Inject]</literal> that specifies a type-based injection point. Tide will lookup any component that extend or 
       implement the specified type and inject an instance of this component: 
       </para>
       <programlisting role="AS3">
[Name("myInjectedComponent")]
public class MyInjectedComponent {

    [Inject]
    public var bla:IMyComponent;
    
}
       </programlisting>
       <para>
       Here no name is used, Tide uses only the target type <literal>IMyComponent</literal> to match with a registered component. If more than one component
       are matching, the result is undefined and the first registered component will be selected. It is thus recommended to register only one component
       for each interface used in injection points and to avoid too generic types in injection points (e.g. <literal>[Inject] public var bla:Object</literal>
       will generally not be very useful). 
       </para>
       <para>
       However it can be useful to register many component implementations for the same interface in the case of service registries. You can define a 
       service interface, register many implementations, and then retrieve all registered implementations with <literal>tideContext.allByType(IMyService)</literal>. 
       This is for example how Tide handles exception converters of message interceptors internally. 
       </para>
       
       <para>
       You can also inject the context object to which the component belongs with either <literal>[In]</literal> or <literal>[Inject]</literal> by specifying
       the source type <literal>Context</literal> or <literal>BaseContext</literal>. This will always be a static injection because the context of a component 
       instance cannot change.
       </para>
       <programlisting role="AS3">
[Inject]
public var myContext:Context;
       </programlisting>
       
       <para>
       Tide manages the lifecycle of the components (instantiation and destruction) and provides a means to react to these events with the annotations
       <literal>[PostConstruct]</literal> and <literal>[Destroy]</literal> than can be put on any public method without argument of the component and 
       will be called by Tide on the corresponding events. <literal>[PostConstruct]</literal> is called after all injections and internal initializations 
       have been done so it can been used to do some custom initialization of a component instance. <literal>[Destroy]</literal> can be used to cleanup 
       used resources.
       </para>
       <programlisting role="AS3">
[Name("myComponent")]
public class MyComponent {

    [PostConstruct]
    public function init():void {
        // ...
    }
    
    [Destroy]
    public function cleanup():void {
        /// ...
    }
}
       </programlisting>
	</section>
	
	<section id="tide.eventbus">
	   <title>Event Bus</title>
	   <para>
	   We have already seen in the previous section how the Tide context can server as a centralized bus to propagate events between managed components.
	   The <literal>[In]</literal> and <literal>[Out]</literal> annotations were used to define a kind of publish/subscribe model for events of type
	   <literal>PropertyChangeEvent</literal>.
	   </para>
	   <para>
	   However other kinds of events can be propagated though the event bus. Tide automatically registers itself as listener to managed events on all
	   managed components, and forwards the events it receives to interested observers by matching the event with the observer definition.
	   </para>
	   <para>
	   Let's see in a first step what kind of events can be managed: 
	   <itemizedlist>
	       <listitem>
	       Events of class <literal>org.granite.tide.events.TideUIEvent</literal> are considered as untyped events and only their name is used to match
	       against observers.
	       </listitem>
	       <listitem>
	       Events of type <literal>org.granite.tide.events.TideUIEvent</literal> (or <literal>TideUIEvent.TIDE_EVENT</literal>), in particular all events
	       extending the <literal>AbstractTideEvent</literal> class are considered as typed events and only their class is used to match against observers.
	       </listitem>
	       <listitem>
	       Events declared with the <literal>[ManagedEvent]</literal> annotation on the dispatcher component are also matched by their type.
	       </listitem>
	   </itemizedlist>
	   </para>
	   <para>
	   There are two ways of dispatching untyped events:
	   </para>
	   <programlisting role="AS3">
public function doSomething():void {
    dispatchEvent(new TideUIEvent("myEvent", arg1, { arg2: "value" }));
}
	   </programlisting>
	   <para>
	   <literal>TideUIEvent</literal> takes a variable list of arguments that will be propagated to all observers.
	   </para>
	   <para>
	   The following method is stricly equivalent and is a bit shorter if you already have an instance of the context somewhere:
	   </para>
       <programlisting role="AS3">
public function doSomething():void {
    tideContext.raiseEvent"myEvent", arg1, { arg2: "value" });
}	  
        </programlisting> 
        
       <para>
       Untyped events are very convenient but as said before they are matched by name (like normal Flex events) and thus are prone to typing errors when
       writing the name of the event in the observer. It is thus recommended when possible to define typed events. As Tide will match by the event class,
       the Flex compiler will immediately detect that a class name has been incorrectly typed.
       </para>
       <para>
       There are two options to create custom typed events. First you can create an event class with the type <literal>TideUIEvent.TIDE_EVENT</literal>. Tide
       will always automatically listen to this type of events and there is no more configuration needed. 
       </para>
       <programlisting role="AS3">
public class MyEvent extends Event {
    
    public var data:Object;
    
    public function MyEvent(data:Object):void {
        super(TideUIEvent.TIDE_EVENT, true, true);
        this.data = data ;
    }
}
       </programlisting>
       <para>
       You can also simply extend the existing <literal>AbstractTideEvent</literal> class:
       </para>
       <programlisting role="AS3">
public class MyEvent extends AbstractTideEvent {
    
    public var data:Object;
    
    public function MyEvent(data:Object):void {
        super();
        this.data = data ;
    }
}
       </programlisting>
	   <para>
	   Note that when creating custom event classes, you should set the <literal>bubbling</literal> and <literal>cancelable</literal> properties of the
	   event to <literal>true</literal>:
	   </para>
	   <para>
	   Bubbling is necessary when you dispatch the event from UI components. It allows to declare only the top level UI components as Tide-managed components,
	   and avoid the performance cost of managing all UI components. For example <literal>ItemRenderer</literal>s can simply dispatch such events, they will
	   be bubbled to their owning UI component and there received and handled by Tide, without Tide knowing anything of the item renderer itself.
	   </para>
	   <para>
	   Cancelable makes possible to call <literal>event.stopPropagation()</literal> to stop Tide from propagating the event further.
	   </para>
	   <para>
	   This first option is easy to use, but creates a compile-time dependency on the Tide framework (either extending <literal>AbstractTideEvent</literal> or 
	   using the type <literal>TIDE_EVENT</literal>). You can alternatively create any Flex custom event and then declare it as a managed event in all 
	   components that dispatch it.
	   </para>
       <programlisting role="AS3">
public class MyEvent extends Event {
    
    public var data:Object;
    
    public function MyEvent(data:Object):void {
        super("myEvent", true, true);
        this.data = data ;
    }
}
       </programlisting>
       <programlisting role="AS3">
[Name("myComponent")]
[ManagedEvent(name="myEvent")]
public class MyComponent extends EventDispatcher {
    
    public function doSomething():void {
        dispatchEvent(new MyEvent({ property: "value" }));
    }
}
       </programlisting>
       <para>
       Note that this second option is more vulnerable to typing errors because you have to write the event name in the <literal>[ManagedEvent]</literal>
       annotation and the Flex compiler does not enforce any control in the annotations.
       </para>
       <para>
       Now that you know how to dispatch an event that Tide will be able to manage, let's see how to tell Tide what to do with this event. The key for this is
       the annotation <literal>[Observer]</literal> that can be put on any public method of a component and will be called when 
       </para>
       <para>
       Once again there are a few possibilities to observe events passed through the bus. For untyped events, you have to specify the name of the event you want 
       to observe in the <literal>[Observer("myEvent")]</literal> annotation. The target observer method can either have a single argument of type
       <literal>TideContextEvent</literal>, or a list of arguments that will be set with the arguments of the source <literal>TideUIEvent</literal>:
       </para>
       <programlisting role="AS3">
[Observer("myEvent")]
public function eventHandler(event:TideContextEvent):void {
   // You can get the arguments from the events.params array
   var arg1:Object = event.params[0];
   var arg2:Object = event.params[1]["arg2"];
   ...
   // arg2 should be equal to "value"
}
       </programlisting>
       <para>
       Or
       </para>
       <programlisting role="AS3">
[Observer("myEvent")]
public function eventHandler(arg1:Object, arg2:Object):void {
    // arg2["arg2"] should be equals to "value"
}
       </programlisting>
       <para>
       One method can listen to more than one event type by specifying multiple <literal>[Observer]</literal> annotations:
       </para>
       <programlisting role="AS3">
[Observer("myEvent")]
[Observer("myOtherEvent")]
public function eventHandler(arg1:Object, arg2:Object):void {
    // arg2["arg2"] should be equals to "value"
}
       </programlisting>
       <para>
       Or by separating the event types with commas:
       </para>
       <programlisting role="AS3">
[Observer("myEvent, myOtherEvent")]
public function eventHandler(arg1:Object, arg2:Object):void {
    // arg2["arg2"] should be equals to "value"
}
       </programlisting>
       <para>
       Observers for typed events can have only one form:
       </para>
       <programlisting role="AS3">
[Observer]
public function eventHandler(event:MyEvent):void {
    // Do something
}
       </programlisting>
       <para>
       The match will always be done on the event class, so there is nothing to declare in the <literal>[Observer]</literal> annotation. Note that this is 
       recommended to use this kind of typed events for coarse grained events in your application, otherwise this can lead to a proliferation of event classes.
       Future versions of Tide will allow for more specific matching on the handler method allowing the reuse of the same event class in different
       use cases.
       </para>
       <para>
       There are other possibilities than the annotation <literal>[Observer]</literal> to register event observers:
       <itemizedlist>
            <listitem>
            <literal>Tide.getInstance().addEventObserver("myEvent", "myComponent", "myMethod")</literal> can be used to register the method <literal>myMethod</literal>
            of the component <literal>myComponent</literal> as observer for the event <literal>myEvent</literal>. This is exactly equivalent as putting the
            annotation <literal>[Observer("myEvent")]</literal> on the method.
            </listitem>
            <listitem>
            <literal>Tide.getInstance().addContextEventListener("myEvent", listener)</literal> can be used to directly register an event listener method for a 
            particular event. It can also be called from the context object with <literal>tideContext.addContextEventListener("myEvent", listener)</literal>.
            </listitem>
       </itemizedlist>
       </para>
       <para>
       If a component has registered an observer for an event and is not instantiated when the event is raised, it will be automatically instantiated, 
       unless it is marked as <literal>[Name("myComponent", autoCreate="false")]</literal>. It is however possible to disable this automatic instantiation 
       for a particular observer with <literal>[Observer("myEvent", create="false")]</literal>. In this case the target component instance will react to the
       event only if it already exists in the context.
       </para>
       <para>
       Now you should be able to easily connect all parts of your application through events. 
       </para>
	</section>
	
	<section id="tide.conversations">
	   <title>Conversations</title>
	   <para>
	   A conversation context shares its two main features with the global context: it is a container of component instances and propagates events between these
	   component instances. It has two important differences:
	   <itemizedlist>
	       <listitem>
	       Many conversation contexts can exist simultaneously in the application.
	       </listitem>
	       <listitem>
           A conversation context can be created and destroyed at any time during the application.	       
	       </listitem>
	   </itemizedlist>
	   </para>
	   <para>
	   It is important to note that all conversation contexts are completely isolated. A component instance in a conversation context can only receive events 
	   dispatched from another component instance in the same conversation context. Similarly when using injection or outjection, the injected instance
	   will be in the same conversation context as the target component instance.
	   </para>
	   <para>
	   Another important thing is that conversation contexts are in fact considered as children of the global context. There are some visibility rules between
	   a conversation context and the global context:
	   <itemizedlist>
	       <listitem>
	       A global component can observe events dispatched from conversation components. Such an observer will receive events from all the existing conversation
	       contexts and can determine if necessary the source context of the event with <literal>event.context</literal>.
	       <warning>Note that in this case all parameters of the event must be serializable (annotated with <literal>[RemoteClass]</literal>) because the parameters 
	       are cloned when passed from one context to another</warning>
	       </listitem>
	       <listitem>
	       A conversation component cannot observe events dispatched from the global context.
	       </listitem>
	       <listitem>
	       The same component name cannot be reused by both a conversation scoped component and a global scoped component. A global component instance can be
	       accessed by its name from any conversation context: if <literal>myComponent</literal> is the name of a global component, 
	       <literal>tideContext.myComponent</literal> will always return the instance of the global component for any existing context.
	       </listitem>
	       <listitem>
	       Similarly when using injection, it is possible to inject a global component instance in a conversation component instance with <literal>[In]</literal>:
	       <programlisting role="AS3">
[Name("myConversationComponent", scope="conversation")]
public class MyConversationComponent {
    
    [In]
    public var myComponent:MyComponent;
    // This will always inject the instance of the global component
}
	       </programlisting>
	       </listitem>
	       <listitem>
	       A conversation component cannot outject its properties to the global context.
	       </listitem>
	       <listitem>
	       Conversation contexts can be nested. In this case the same visibility rules apply between a conversation context and its parent context.
	       </listitem>
	   </itemizedlist>
	   </para>
	   
       <para>
       A conversation context can be simply created by <literal>Tide.getInstance().getContext("someConversationId")</literal>, however the recommended way 
       to create a new conversation is to dispatch an event that implement <literal>IConversationEvent</literal> from the global context (or from a conversation
       context to create a nested conversation). The <literal>IConversationEvent</literal> has a <literal>conversationId</literal> property that will be used
       as id of the newly created conversation. The built-in <literal>TideUIConversationEvent</literal> can be used instead of <literal>TideUIEvent</literal>
       when using untyped events. If the conversation id is set to <literal>null</literal>, Tide will automatically assign an incremental numeric id to the new context.
       </para>
       <programlisting role="XML">
<![CDATA[<mx:List id="list" dataProvider="{customerRecords}" 
    change="dispatchEvent(new TideUIConversationEvent(list.selectedItem.id, "viewRecord", list.selectedItem))")/>]]>
       </programlisting>
       <programlisting role="AS3">
[Name("customerRecordController")]
public class CustomerRecordController {

    [Observer("viewRecord")]
    public function selectRecord(record:Record):void {
        // Start the conversation
        // For example create a view and display it somewhere
    }
}
       </programlisting>
       <para>
       A conversation context can be destroyed by <literal>tideContext.meta_end()</literal>. We'll see the use of the <literal>merge</literal> argument of 
       this method later.
       </para>
       
       <para>
       Here is a more complete example of end-to-end conversation handling by a controller:
       </para>
       <programlisting role="AS3">
[Name("customerRecordController", scope="conversation")]
public class CustomerRecordController {

    [In]
    public var mainTabNavigator:TabNavigator;
    
    [In(create="true")]
    public var recordView:RecordView;
    

    [Observer("viewRecord")]
    public function viewRecord(record:Record):void {
        recordView.record = record;
        mainTabNavigator.addChild(recordView);
    }
    
    [Observer("closeRecord")]
    public function closeRecord(event:TideContextEvent):void {
        mainTabNavigator.removeChild(recordView);
        event.context.meta_end();
    }
}
       </programlisting>
       <para>
       RecordView.mxml:
       </para>
       <programlisting role="AS3">
<![CDATA[<mx:Panel label="Record #{record.id}">
    <mx:Metadata>[Name("recordView", scope="conversation")]</mx:Metadata>
    <mx:Script>
        [Bindable]
        public var record:Record;
    </mx:Script>
    
    <mx:Label text="{record.description}"/>
    
    <mx:Button label="Close" 
        click="dispatchEvent(new TideUIEvent('closeRecord'))"/>
</mx:Panel>]]>
       </programlisting>
       <para>
       The use case is that we want to open a new tab to display a customer record when the user clicks on the customer in a list. Here is the process:
        <orderedlist>
            <listitem>
            The click on the list dispatches a conversation event with the id of the record as conversation id and the selected record as argument. 
            </listitem>
            <listitem>
            Tide creates a new context with the specified id, instantiates the controller component and calls the observer method <literal>viewRecord</literal>. 
            </listitem>
            <listitem>
            The controller uses an injected view that is instantiated and managed by Tide (with the <literal>[In(create="true")]</literal>), sets it
            <literal>record</literal> property and adds it to the main tab navigator. Note that we could have outjected the record from the controller and 
            injected it in the view but 
            </listitem>            
        </orderedlist>
        If the user clicks on many elements in the list, one tab will be created for each element. 
       </para>
       <para>
       The user can then click on the <emphasis>Close</emphasis> button that will trigger the <literal>closeRecord</literal> event. The controller will then
       remove the tab from the navigator and end the conversation context. <literal>meta_end()</literal> schedules the destruction of the context for the next
       frame, then all component instances of the context and the context itself are destroyed. 
       </para>
	</section>
	
	<section id="tide.data">
	   <title>Integration with Data Management</title>
	   <para>
	   One of the main points of the Tide framework is that its concepts are completely integrated with the data management features. In particular each 
	   context holds its own entity cache so you can modify data in one conversation without touching the others. Only when the user decides to save its changes
	   you can trigger the merge of the changes in the global context and its entity cache, and to the other conversation contexts.
	   </para>
	   <para>
	   Each context having its own entity cache has some implications:
	   <itemizedlist>
	       <listitem>
	       The same entity instance (with the same <literal>uid</literal>) can exist once in each context.
	       </listitem>
	       <listitem>
	       All changes on an entity in the global cache are always propagated to the caches of all conversation contexts (but will NOT overwrite changes made
	       directly in the conversation context).
	       </listitem>
	       <listitem>
	       When dispatching events which have entity arguments from the global context to conversation contexts (with <literal>IConversationEvent</literal>) 
	       or the other way (global observers of conversation events), Tide has to translate the event payload from one cache to the other. In the previous example,
	       the <literal>Record</literal> received by the controller is NOT the same instance as the one dispatched from the list, it is the copy of this object
	       in the conversation context entity cache. That means that you can do whatever you want on this object, it will not be reflected on the source list.
	       </listitem>
	       <listitem>
	       At any point, you can merge the cache of a conversation context in the global context (and thus in all other conversation contexts) with 
	       <literal>tideContext.meta_mergeInGlobalContext()</literal> or <literal>tideContext.meta_mergeInParentContext()</literal> (for nested conversations).
	       Also when ending a conversation context, <literal>tideContext.meta_end(true)</literal> will merge the changes in the parent context before ending the
	       conversation. <literal>tideContext.meta_end(false)</literal> will drop any change made in the conversation context and is suitable for 
	       <emphasis>Cancel</emphasis> buttons for example.
	       </listitem>
	   </itemizedlist>
	   </para>
	</section>
	
	<section id="tide.plugins">
	   <title>Extension and Plugins</title>
	   <para>
	   Tide provides a few extension points that can be used to extend its functionality. 
	   </para>
	   <para>
	   First there are four events that are dispatched on some internal events:
        <itemizedlist>
            <listitem>
            <literal>org.granite.tide.startup</literal>: Dispatched at application startup, can be used to do some global initialization.
            </listitem>
            <listitem>
            <literal>org.granite.tide.contextCreate</literal>: Dispatched at creation of a new conversation context, can be used to do initialization of the
            context.
            </listitem>
            <listitem>
            <literal>org.granite.tide.contextDestroy</literal>: Dispatched at destruction of a conversation context, can be used to cleanup resources.
            </listitem>
            <listitem>
            <literal>org.granite.tide.contextResult</literal>: Dispatched at each remoting result.
            </listitem>
            <listitem>
            <literal>org.granite.tide.contextFault</literal>: Dispatched at each remoting fault, can be used to run global handling of faults.
            </listitem>
            <listitem>
            <literal>org.granite.tide.login</literal>: Dispatched at user login (or relogin when the user refreshes the browser page).
            </listitem>
            <listitem>
            <literal>org.granite.tide.logout</literal>: Dispatched before user logout.
            </listitem>
            <listitem>
            <literal>org.granite.tide.loggedOut</literal>: Dispatched after user logout.
            </listitem>
        </itemizedlist>
        All these events can be observed from any component as standard Tide events:
	   </para>
	   <programlisting role="AS3">
[Name("myComponent")]
public class MyComponent {
    
    [Observe("org.granite.tide.startup")]
    public function startup():void {
        // Do some initialization stuff here...
    }
} 
	   </programlisting>
	   <para>
	   It is also possible to integrate a bit more deeply with the framework by implementing a plugin (the interface <literal>ITidePlugin</literal>).
	   A plugin must be a singleton with a <literal>getInstance()</literal> method and implement a setter for the <literal>tide</literal> property.
	   It can then register event listeners on the Tide instance itself. The type of the dispatched event is <literal>TidePluginEvent</literal> and 
	   it contains some parameters depending on the event in its map property <literal>params</literal>. The following events are dispatched:
	   <itemizedlist>
	       <listitem>
	       <literal>org.granite.tide.plugin.addComponent</literal>: Dispatched when a new component is registered, can be used to participate in the scan of 
	       the annotations. <literal>event.params.descriptor</literal> contains the internal component descriptor (of type <literal>ComponentDescriptor</literal>),
	       see the API documentation for details on this class, and <literal>event.params.type</literal> contains the <literal>Type</literal> for the 
	       component class that can be used to retrieve annotations or metadata.
	       </listitem>
	       <listitem>
	       <literal>org.granite.tide.plugin.setCredentials</literal>: Dispatched when the user credentials are defined, it can be used to set the user credentials
	       on some object of the plugin. <literal>event.params</literal> has two parameters <literal>username</literal> and <literal>password</literal>.
	       </listitem>
           <listitem>
           <literal>org.granite.tide.plugin.loginSuccess</literal>: Dispatched when the user has been logged in successfully. <literal>event.params.sessionId</literal>
           contains the user session id received from the server.
           </listitem>
           <listitem>
           <literal>org.granite.tide.plugin.loginFault</literal>: Dispatched when the user login has failed.
           </listitem>
           <listitem>
           <literal>org.granite.tide.plugin.logout</literal>: Dispatched when the user logs out.
           </listitem>
	   </itemizedlist>
	   </para>
	   <para>
	   Here is an example of a simple (and useless) plugin that traces the creation of all components annotated with <literal>[Trace]</literal>:
	   </para>
	   <programlisting role="AS3">
public class TideTrace implements ITidePlugin {
   
    private static var _tideTrace:TideTrace;
    
    
    public static function getInstance():TideTrace {
        if (!_tideTrace)
            _tideTrace = new TideTrace();            
        return _tideTrace;
    }
    
    public function set tide(tide:Tide):void {
        tide.addEventListener(Tide.PLUGIN_ADD_COMPONENT, addComponent);
    }
    
    private function addComponent(event:TidePluginEvent):void {
        var descriptor:ComponentDescriptor = event.params.descriptor as ComponentDescriptor;
        var type:Type = event.params.type as Type;
        var anno:Annotation = type.getAnnotationNoCache('Trace');
        if (anno != null)
            trace("Component added: " + descriptor.name);
    }
}
	   </programlisting>
	</section>
	
	<section id="tide.security">
        <title>Security</title>
        <para>
        There is not much Tide can do concerning security, however it is possible to declare that a particular component can exists only when the user
        is authenticated so its state cannot be accessed or modified from unauthorized users. You can use <literal>[Name("myComponent", restrict="true")]</literal> 
        on a components to specify this.
        </para>
        <para> 
        Tide will then automatically clear all data of the restricted components when the user logs out and the session becomes anonymous.        
        </para>
 	</section>
 	
 	<section id="tide.modules">   
	    <title>Modules</title>
	    <para>
	    If you have a big number of components to initialize, your main MXML application will quickly be polluted with lots of Tide initializations. 
	    This can be cleaned up by implementing a Tide initialization module class, which just has to implement <literal>ITideModule</literal>. Then you can
	    use <literal>addModule</literal> to call the initialization of a whole application:
	    </para>
        <programlisting role="AS3">
Tide.getInstance().addModule(MyModule);

public class MyModule implements ITideModule {
   public function init(tide:Tide):void {
       tide.addExceptionHandler(ValidationExceptionHandler);
       ...

       tide.addComponents([Component1, Component2]);
       tide.addComponent("comp3", Component3);
       ...
   }
}
        </programlisting>
        <para>
        You can think of it as a XML configuration file, such as Seam <literal>components.xml</literal> or Spring <literal>context.xml</literal>.
        </para>
        <para>
        Using Tide modules is also necessary if you need to register components that are dynamically loaded from a Flex module. In this case, Tide will need to 
        know the Flex <literal>ApplicationDomain</literal> to which the component classes belong, and you have to pass it to the 
        <literal>Tide.addModule()</literal> method.
        </para>
        <para>
        Here is an example on how to handle dynamic loading of Flex modules :
        </para>
        <programlisting role="AS3">
<![CDATA[private var _moduleAppDomain:ApplicationDomain;

public function loadModule(path:String):void {
    var info:IModuleInfo = ModuleManager.getModule(path);
    info.addEventListener(ModuleEvent.READY, moduleReadyHandler, false, 0, true);
    _moduleAppDomain = new ApplicationDomain(ApplicationDomain.currentDomain);
    info.load(appDomain);
}

private function moduleReadyHandler(event:ModuleEvent):void {
    var loadedModule:Object = event.module.factory.create();
    Tide.getInstance().addModule(loadedModule, _moduleAppDomain);
}]]>
        </programlisting>
        <para>
        Alternatively you can also use the Flex MX or Spark <literal>ModuleLoader</literal> components, and just ensure that you are using a specific application
        domain when loading a module.
        </para>
        <programlisting role="XML">
<![CDATA[<mx:ModuleLoader id="moduleLoader"
    applicationDomain="{new ApplicationDomain(ApplicationDomain.currentDomain)}"
    ready="Tide.getInstance().addModule(moduleLoader.child, moduleLoader.applicationDomain)"/>]]> 
        </programlisting>
        <para>
        You can then change the loaded module with this code :
        </para>
        <programlisting role="AS3">
private function changeModule(modulePath:String):void {
    if (moduleLoader.url != modulePath) {
        moduleLoader.applicationDomain = new ApplicationDomain(ApplicationDomain.currentDomain);
        moduleLoader.unloadModule();
        moduleLoader.loadModule(modulePath);
    }
}
        </programlisting>        
 	</section>
 	
 	<section id="tide.deeplinking">
 	      <title>Support for Deep Linking</title>
 	      <para>
 	      Flash/Flex provides an API to handle SEO friendly linking from the url of the swf. For example you may want to provide a simple url to access a particular
 	      resource : <literal>http://my.domain.com/shop/shop.html#product/display/tv</literal>.
 	      To have this working you have to generate the html wrapper with Flash Builder / Ant / Maven and use the html wrapper instead of accessing the 
 	      <literal>swf</literal> directly. See <ulink url="http://livedocs.adobe.com/flex/3/html/help.html?content=deep_linking_2.html">here</ulink> for more
 	      details on Flex deep linking. 
 	      </para>
 	      <para>
 	      Tide provides a way to integrate deep linking with the MVC framework. It uses a technique inspired by <literal>JAX-RS</literal> so that changes in the
 	      browser url will trigger a method on a component. It first requires to enable the corresponding Tide plugin just after the Tide initialization with :
 	      </para>
 	      <programlisting role="AS3">
Tide.getInstance().initApplication();
Tide.getInstance().addPlugin(TideUrlMapping.getInstance()); 	      
 	      </programlisting>
 	      <para>
 	      You will also need to keep the annotation <literal>[Path]</literal> in your compilation options in Flash Builder / Ant / Maven.
 	      </para>
 	      <para>
 	      Once enabled, the plugin will listen to browser url changes, and split the url after # in two parts. The part before the first slash will identify the 
 	      target controller, and the part after the first slash will determine the target method. 
 	      In the previous example, the controller has to be annotated with <literal>[Path("product")]</literal> and the method with <literal>[Path("display/tv")]</literal> :
 	      </para>
 	      <programlisting role="AS3">
[Name("productController")]
[Path("product")]
public class ProductController {

    [Path("display/tv")]
    public function displayTv():void {
        // Do something to display the TV...
    }
}
 	      </programlisting>
 	      <para>
 	      Of course you won't want to have a different method for each kind of resource so you can use placeholders that will match method arguments : 
 	      </para>
          <programlisting role="AS3">
[Name("productController")]
[Path("product")]
public class ProductController {

    [Path("display/{0}")]
    public function display(productType:String):void {
        // Do something to display the product...
    }
}
          </programlisting>
 	</section>
</chapter>
